import inspect
from typing import (
    List,
    Union,
    Type,
    Any,
    get_type_hints,
    get_origin,
    get_args,
    Set
)
from pumpking.pipeline import Step, PumpkingPipeline
from pumpking.exceptions import PipelineConfigurationError
from pumpking.models import ChunkNode, ChunkPayload, DocumentRoot


def validate(pipeline: Union[Step, List[Any], PumpkingPipeline]) -> None:
    """
    Performs comprehensive static analysis on the pipeline structure to ensure type safety
    and configuration validity before execution.

    This function traverses the pipeline topology, which can consist of sequential steps,
    parallel blocks, or a mix of both. It employs runtime type introspection to verify
    that the strategies configured within each step are compatible with the data flow
    managed by the Pumpking architecture.

    The validation process encompasses four primary checks. First, it verifies structural
    integrity to ensure the pipeline object itself is well-formed. Second, it checks
    type compatibility by inspecting the 'execute' method signature of each strategy,
    ensuring it can accept the standard data types (strings or ChunkPayloads) that the
    framework propagates. Third, it validates parallel execution blocks to ensure that
    all branches are valid and that there are no aliasing collisions between sibling steps,
    which would cause overwrites in the resulting graph. Finally, it validates any
    attached annotators to ensure they are capable of processing the raw string content
    generated by their parent step.

    Args:
        pipeline: The pipeline definition object, which may be a single Step, a list of
            Steps (representing a sequence or parallel block depending on context), or
            an instantiated PumpkingPipeline object.

    Raises:
        PipelineConfigurationError: If any validation rule is violated, such as a type
            mismatch between a strategy's expected input and the framework's output,
            or duplicate aliases within a parallel processing block.
    """
    steps = _normalize_pipeline(pipeline)

    for index, item in enumerate(steps):
        if isinstance(item, Step):
            _validate_step_compatibility(item)
            _validate_annotators(item)

        elif isinstance(item, list):
            _validate_parallel_block(item)
        else:
            raise PipelineConfigurationError(f"Invalid item at index {index}: {item}")


def _normalize_pipeline(pipeline: Union[Step, List[Any], PumpkingPipeline]) -> List[Any]:
    """
    Normalizes the input pipeline structure into a standardized flat list of executable units.

    The pipeline definition can take various forms: a single Step instance, a raw list
    of steps defining a topology, or a PumpkingPipeline wrapper object. This utility
    unifies these formats into a consistent list representation to simplify downstream
    iteration and validation logic.

    Args:
        pipeline: The raw pipeline structure provided by the user.

    Returns:
        A list where each element is either a Step instance (representing a sequential
        stage) or a list of Step instances (representing a parallel processing block).

    Raises:
        PipelineConfigurationError: If the input object is of an unknown or unsupported type.
    """
    if isinstance(pipeline, PumpkingPipeline):
        return pipeline.steps
    if isinstance(pipeline, Step):
        return [pipeline]
    if isinstance(pipeline, list):
        return pipeline
    raise PipelineConfigurationError(f"Unknown pipeline type: {type(pipeline)}")


def _validate_step_compatibility(step: Step) -> None:
    """
    Verifies that the strategy encapsulated by a Step is compatible with the Pumpking
    data flow protocol using type introspection.

    In the Pumpking architecture, the Pipeline orchestrator acts as a universal adapter.
    It feeds strategies with either raw text strings, individual ChunkPayload objects,
    or lists of ChunkPayloads (for batch processing). Therefore, a valid strategy must
    be capable of accepting at least one of these types in its 'execute' method.

    This function inspects the type hints of the 'data' argument in the strategy's
    'execute' method. It asserts that the defined type signature is permissive enough
    to handle the standard inputs provided by the framework. If a strategy defines a
    restrictive input type that the framework cannot produce (e.g., expecting an integer
    as the primary input), this validation check will fail.

    Args:
        step: The Step instance containing the strategy to validate.

    Raises:
        PipelineConfigurationError: If the strategy's input type signature is strictly
            incompatible with strings, ChunkPayloads, or lists thereof.
    """
    try:
        hints = get_type_hints(step.strategy.execute)
        strategy_input_type = hints.get('data', Any)
    except Exception:
        strategy_input_type = Any

    if strategy_input_type is Any:
        return

    allows_str = _type_allows(strategy_input_type, str)
    allows_payload = _type_allows(strategy_input_type, ChunkPayload)
    allows_list = _type_allows(strategy_input_type, list) or _type_allows(strategy_input_type, List)

    if not (allows_str or allows_payload or allows_list):
        raise PipelineConfigurationError(
            f"Type Mismatch: Step '{step.alias}' strategy expects {strategy_input_type}, "
            f"which is incompatible with Pumpking's standard data flow (str/ChunkPayload)."
        )


def _validate_annotators(step: Step) -> None:
    """
    Validates that all annotators attached to a Step are compatible with the annotation
    execution model.

    Annotators in Pumpking are applied to the generated content of a payload. Since
    content is invariably a string (e.g., the text of a summary or a chunk), annotator
    strategies must be capable of accepting a string input. This function iterates
    through all registered annotators on the step and inspects their 'execute' method
    signatures to enforce this requirement.

    Args:
        step: The Step instance whose annotators are to be validated.

    Raises:
        PipelineConfigurationError: If any annotator's strategy does not accept string inputs.
    """
    for alias, strategy in step.annotators.items():
        try:
            hints = get_type_hints(strategy.execute)
            input_type = hints.get('data', Any)
        except Exception:
            input_type = Any

        if not _type_allows(input_type, str):
            raise PipelineConfigurationError(
                f"Annotator Type Mismatch: Annotator '{alias}' on step '{step.alias}' "
                f"expects {input_type} but receives 'str' from the payload content."
            )


def _validate_parallel_block(branches: List[Step]) -> None:
    """
    Validates a block of parallel execution branches for structural correctness and
    naming conflicts.

    Parallel blocks allow multiple strategies to process the same input node concurrently.
    This function performs two critical checks. First, it ensures that all items within
    the block are valid Step instances. Second, it enforces uniqueness of aliases among
    the sibling steps. Unique aliases are mandatory because the results from parallel
    branches are merged into the graph structure, and ambiguous aliases would make it
    impossible to distinguish which strategy produced which branch.

    Additionally, this function recursively invokes step compatibility validation for
    each branch to ensure type safety within the parallel execution context.

    Args:
        branches: A list of Step instances representing the parallel branches.

    Raises:
        PipelineConfigurationError: If the block contains non-Step items, if duplicate
            aliases are detected, or if any individual branch fails its compatibility check.
    """
    aliases: Set[str] = set()

    for idx, step in enumerate(branches):
        if not isinstance(step, Step):
            raise PipelineConfigurationError(f"Parallel block contains non-Step item at index {idx}")

        if step.alias in aliases:
            raise PipelineConfigurationError(f"Duplicate step alias '{step.alias}' in parallel block")
        aliases.add(step.alias)

        try:
            _validate_step_compatibility(step)
            _validate_annotators(step)
        except PipelineConfigurationError as e:
            raise PipelineConfigurationError(f"Branch {idx} error: {str(e)}")


def _type_allows(target_hint: Any, check_type: Type) -> bool:
    """
    Recursively determines if a specific type is permissible under a given type hint.

    This utility function navigates complex type definitions, including Unions and
    Generics, to verify type compatibility. It is used to check if a strict type
    (like 'str') satisfies a potentially complex hint (like 'Union[str, int]' or 'Any').

    The logic handles three main cases: direct equality or 'Any' (always compatible),
    Union types (compatible if any member of the union is compatible), and generic Lists
    (compatible if the list container matches). This allows the validator to support
    polymorphic strategies that accept multiple input formats.

    Args:
        target_hint: The type hint definition to check against (e.g., from a function signature).
        check_type: The specific concrete type to verify (e.g., str or ChunkPayload).

    Returns:
        True if the check_type is a valid subtype or member of the target_hint, False otherwise.
    """
    if target_hint is Any:
        return True
    if target_hint == check_type:
        return True

    origin = get_origin(target_hint)
    args = get_args(target_hint)

    if origin is Union:
        return any(_type_allows(arg, check_type) for arg in args)

    if origin is list or origin is List:
        return True

    return False